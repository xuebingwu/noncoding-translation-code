# R script for decomposing a chromatogram generated by Sanger sequencing of a mixture of multiple sequences
# modified from TIDE

	# # len: length of sequences used for decomposition   
	# example
	# decomposition(c('c32-4.ab1','c32-20.ab1'),'c32.ab1','AGAGATCA',500)
	# decomposition('c32-4-20.seq','c32.ab1','AGAGATCA',500)


# required library
library(Biostrings)
library(sangerseqR)
library(nnls)

import <- function(chromatogram_file, sample_name = NA) {
  ## import data from a sanger sequencing chromatogram file 
  ## Arguments: 
  ##   chromatogram_file (char) : Sanger chromatogram files (.ab1 or .scf) 
  ##   sample_name: if NA will use file name
  ## Return:
  ##   list(name,sequence,peak_height_matrix)
  
  require("Biostrings")
  require("sangerseqR")
   
  patched.readsangerseq<-function(filename)
    #This is a slightly modified version of readsangerseq() in the sangerseqR package
    #It fixes a problem with reading some .ab1 files, which appear to have an aberrant last 
    #character in the sequence strings, which sangerseq() cannot cope with. It returns a sangerseq object.
  { require(sangerseqR)
    fc <- file(filename, open = "rb")
    rawdata <- readBin(fc, what = "raw", n = 1.2 * file.info(filename)$size)
    close(fc)
    filetype <- suppressWarnings(rawToChar(rawdata[1:4]))
    if (filetype == ".scf") {
      seq <- read.scf(filename)
    }
    else if (filetype == "ABIF") {
      seq <- read.abif(filename)
      l<-nchar(seq@data$PBAS.1)
      if(! substr(seq@data$PBAS.1,l,l) %in% LETTERS) { #if last character is not uppercase text
        seq@data$PBAS.1<-substr(seq@data$PBAS.1,1,l-1)
      }
      l<-nchar(seq@data$PBAS.2)
      if(! substr(seq@data$PBAS.2,l,l) %in% LETTERS) { #if last character is not uppercase text
        seq@data$PBAS.2<-substr(seq@data$PBAS.2,1,l-1)
      }
    }
    else stop(paste("Invalid File: ",filename))
    return(sangerseq(seq))
  }
  
  ##load data (now automatically handles IBAF and SCF formats)
  sample<-patched.readsangerseq(chromatogram_file)
    
  #extract primary sequences as called by sequencer:
  sequence <- primarySeq(sample)
  
  #extract  data:
  if(peakPosMatrix(sample)[1,1]==1){peakPosMatrix(sample)[1,1] <- 2}
  peak_loc <- peakPosMatrix(sample)[,1]-1 #sangerseq() added 1, we substract it again
  peak_height <- traceMatrix(sample)[peak_loc,] #matrix with a column for each base 
  peak_height[is.na(peak_height)]<-0 #set NAs to 0
  colnames(peak_height)<-c("A","C","G","T")
  
  if(is.na(sample_name)) {sample_name = chromatogram_file} 
	  
  return(list(
	name=sample_name,
	sequence=sequence,
    peak_height=peak_height))
}

find_end_of_common_seq <- function(seq,end_of_common_seq){
	# find a substring end_of_common_seq in seq
	# return the end of the match, or -1 if no match
	
	# default no match found
	match_end = -1
	
	# search for match
	Dend_of_common_seq<-DNAString(end_of_common_seq)
    align <- pairwiseAlignment(pattern=Dend_of_common_seq, subject=seq, type="local")
    hit <- identical(end_of_common_seq, as.character(subject(align))) # hit if full match found
	
	# if match found, return the position of the first position to be decomposed
	if(hit){
		match_end = end(subject(align))+1
	}
	
	return(match_end)
}


trim <- function(data,end_of_common_seq,len){
	# function to trim a data: find end_of_common_seq, then only keep len nucleotides starting from end_of_common_seq
	# data: output from import
	# end_of_common_seq: a short sequence present in all input sequences 5' end of the variable region
	# len: length of sequences used for decomposition,
	# return: trimmed data
	
	seqstart = find_end_of_common_seq(data$sequence,end_of_common_seq)
	
	if(seqstart < 0){
	    print(paste("no end_of_common_seq found in: ",data$sequence,  
	               "\n end_of_common_seq:", end_of_common_seq))
        data$sequence=DNAString('')
        data$peak_height=0
        return(data)
	} else if (seqstart+len-1 > length(data$sequence)){
		# not long enough, fill with N
		print(paste("extend with N for short sequence : ",data$name))
		data$peak_height = rbind(data$peak_height,matrix(0,nr=seqstart+len-1-length(data$sequence),nc=4))
		data$sequence = paste(data$sequence,paste(rep("N",seqstart+len-1-length(data$sequence)),collapse=''),sep='')
	} 
	data$sequence = substr(data$sequence,seqstart,seqstart+len-1)
	data$peak_height = data$peak_height[seqstart:(seqstart+len-1),]
	return(data)
}

# average signal for each nucleotide, learned from a specific chromatogram
# use min_frac to determine the position with high quality, and only use data from high quality position to calculate statistics
# min
average_nucleotide_signal <- function(data,min_frac=0.8,min_score=0) {
	s <- matrix(0,nc=4,nr=7)
	colnames(s) = c("A","C","G","T")
	rownames(s) = c("A","C","G","T","N","count",'background')
	
	# min count of each position/row
	min_count = rowSums(data$peak_height)*min_frac
	min_count[min_count < min_score] = min_score
	
	for(i in 1:4){
		valid = (data$peak_height[,i] > min_count)
		n_valid = sum(valid) 
		if(n_valid < 3){
			stop(paste("the sequence",data$name,"contains less than three",colnames(data$peak_height)[i]),", not enough to build the signal")
		}
		s[i,] <- apply(data$peak_height[valid,],2,median)
		s[6,i] <- n_valid
	}

	# calculating background
	s[7,] = (colSums(s[1:4,]) - apply(s[1:4,],2,max))/3
	return(s)
}

# background = signal[7,]
subtract_background <- function(data,background){
	for(i in 1:4){
		data$peak_height[,i] = data$peak_height[,i] - background[i]
	}
	data$peak_height[data$peak_height<0] = 0
	return(data)
}

subtract_signal_background <- function(signal){
	for(i in 1:4){
		signal[1:4,i] = signal[1:4,i] - signal[7,i]
	}
	signal[signal<0] = 0
	return(signal)
}

# create a data using sequence
generate_data_from_sequence <- function(name,seq,signal){
	h = list('A'=1,'C'=2,'G'=3,'T'=4,'N'=5)
	# check if non ACGT sequence present
	nonACGT= gsub('[ACGTN]','',seq)
	if(nonACGT != "") {stop(paste(name," contains non-ACGT letters!\n",nonACGT))}
	seqs = unlist(strsplit(seq,""))
	peak_height = matrix(0,nr=length(seqs),nc=4)
	for(i in 1:length(seqs)){
		peak_height[i,] = signal[h[[seqs[i]]],]
	}
	return(list(name=name,sequence=DNAString(seq),peak_height=peak_height))
}

# generate all possible polyA cleavage sequences
generate_polya_cleavages <- function(seq, tail){
	seqs = character()
	for (i in 1:nchar(seq)){
		seqs = rbind(seqs,c(i,paste(substr(seq,1,i),tail,sep='')))
	}
	return(seqs)
}

# 
find_polya_site <- function(data,k,w){
	x = data$peak_height[,1]  # A signal
	s = numeric()
	for (i in 1:(length(x)-w+1)){
		s = c(s,mean(sort(x[i:(i+w-1)])[1:k]))
	}
	#plot(s,type='h')
}

decomposition <- function(component_files, mixture_file, end_of_common_seq, len, remove_background=FALSE, min_frac=0.8,tail=NA,verbose=FALSE) {  
	# # len: length of sequences used for decomposition   
	# example
	# decomposition(c('c32-4.ab1','c32-20.ab1'),'c32.ab1','AGAGATCA',500)
	# decomposition('c32-4-20.seq','c32.ab1','AGAGATCA',500)
	
  require("nnls")
  
  I_matrix <- c()
  I_vec <- c()
  sample_names <- c()
    
  # load mixture file
  if(verbose){
      print("loading mixture to be decomposed...")
      }
  data_pre_trim = import(mixture_file)
  if(remove_background){
	  signal = average_nucleotide_signal(data_pre_trim,min_frac)
	  data_pre_trim = subtract_background(data_pre_trim,signal[7,])
  }
  
  if(length(component_files)>1){

	  data = trim(data_pre_trim,end_of_common_seq,len)
      
      if (length(data$sequence)==0){ # didn't find common sequence
                return(list(
                            name=mixture_file,
                            Perc=NULL,
                            pv=NULL, 
                            NNFIT=NULL,
                            R2=0
                            ))  

          }
      
	  I_vec = as.vector(data$peak_height)
	  
	  # load each component file if a list
	  for (i in 1:length(component_files)) {
          if(verbose){
              print(paste("loading component signal from file:",component_files[i]))
              }
		  data_pre_trim = import(component_files[i])
		  if(remove_background){
			  signal = average_nucleotide_signal(data_pre_trim,min_frac)
			  data_pre_trim = subtract_background(data_pre_trim,signal[7,])
		  }
		  data = trim(data_pre_trim,end_of_common_seq,len)
		  peak_height_as_vector = as.vector(data$peak_height)
		  identical = FALSE
		  if(i>1){
		  	for(j in (i-1):1){
			  if (all(peak_height_as_vector  == I_matrix[,j]))
			  {
                  if(verbose){
                      print(paste("ignore signal: ",component_files[i],", after trimming is identical to",component_files[j]))
                      }
				  identical = TRUE
				  break
			  }
		  	}
		  }
		  if(identical == FALSE){
		  	# stack up the data
			I_matrix = cbind(I_matrix,peak_height_as_vector)
		  	sample_names = c(sample_names,data$name)
	  	  }
	  }
  } else { # a single file, assume components only given by sequence 
     if(verbose){
         print("calculate median signal for each nucleotide from mixture signals...")
         }
	 signal = average_nucleotide_signal(data_pre_trim,0.8)
      if(verbose){
         print(signal)
          }
	 if(remove_background){
	 	signal = subtract_signal_background(signal)
		if(verbose){
            print(signal)
            }
 	 }
      if(verbose){
         print("loading component sequences")
          }
	 seqs = read.table(component_files,header=F,stringsAsFactors=F)
	 
	 # polyA cleavage
	 if (is.na(tail) == FALSE){
		 len = nchar(seqs[1,2]) - nchar(end_of_common_seq) + nchar(tail)
         if(verbose){
             print(paste("decomposition window size reset to ",len))
             print("generating all possible cleavage and tailed products")
             }
		 seqs = generate_polya_cleavages(seqs[1,2],tail)
	 }
	 

     data = trim(data_pre_trim,end_of_common_seq,len)
	 
	 cols = 1:4 # only A or all 4 bases
     I_vec = as.vector(data$peak_height[,cols])
      if(verbose){
         print(length(I_vec))
          }
	 
	 
	 uniq = c() # index for unique sequences
      if(verbose){
         print(paste(nrow(seqs)," sequence loaded"))
          }
	 for (i in 1:nrow(seqs)){
		 seqs[i,2] = toupper(seqs[i,2])
		 seqstart = find_end_of_common_seq(seqs[i,2],end_of_common_seq)	
	 	 if(seqstart < 0){
	 	     print(paste("no end_of_common_seq found in: ",seqs[i,1],  
	 	               "\n end_of_common_seq:", end_of_common_seq))
			 next
	 	 } else if (seqstart+len-1 > nchar(as.character(seqs[i,2]))){
	 		# not long enough, fill with N
             if(verbose){
                print(paste("extend with N for short sequence : ",seqs[i,1]))
                 }
	 		seqs[i,2] = paste(seqs[i,2],paste(rep("N",seqstart+len-1-length(seqs[i,2])),collapse=''),sep='')
	 	 } 
	 	 seqs[i,2] = substr(seqs[i,2],seqstart,seqstart+len-1)
		 		 
		 new_sequence = TRUE
		 if(i>1){
		 	for(j in uniq){
			 	if(seqs[i,2] == seqs[j,2]){
                    if(verbose){
                        print(paste("ignore signal: ",seqs[i,1],", after trimming is identical to",seqs[j,1]))
                        }
   			  		new_sequence = FALSE
   			  		break
			 	}
			 }
	 	 }
		 if(new_sequence){
             if(verbose){
                print(paste("creating chromatogram for sequence: ",seqs[i,1]))
                 }
		 	data = generate_data_from_sequence(as.character(seqs[i,1]),as.character(seqs[i,2]),signal)
	  		# stack up the data
			I_matrix = cbind(I_matrix,as.vector(data$peak_height[,cols]))
	  		sample_names = c(sample_names,data$name)
			uniq = c(uniq,i)
  	  	}
	 }
  }
            
   if(verbose){
      print(dim(I_matrix))
      print(length(I_vec))
      #print(I_matrix)
       }
  #non-negative linear fit:
  NNFIT <- nnls(I_matrix,I_vec)
  
  ## pvalue calculation (source: https://www.princeton.edu/~slynch/soc504/mult_reg2.pdf)
  #standard error:
  se <- sqrt(diag((sum((NNFIT$fitted-I_vec)^2)/(nrow(I_matrix)-ncol(I_matrix)))*solve(t(I_matrix)%*%I_matrix)));
  
  #p-value:
  pv <- 2*pnorm(-abs(NNFIT$x/se))
  
  #R^2
  Rsq <- cor(NNFIT$fit,I_vec)^2
  
  #components in percentages:
  comper<-(Rsq*100*(NNFIT$x/sum(NNFIT$x)))
    
  decomp.summary <- data.frame(percentage = round(comper,1), pvalue = signif(pv,2))
  rownames(decomp.summary) <- sample_names

    if(verbose){
      print(decomp.summary)
        }
  
    # plot is useful for polyA tail length decomposition
  #par(cex.axis=min(1,50/length(decomp.summary$percentage)))
  #pdf(paste(mixture_file,'.pdf',sep=''),width=10,height=5)
  #plot(1:length(decomp.summary$percentage),
  #           decomp.summary$percentage,type='h',
  #           xlab='',ylab='percentage',
  #           bty='n',main=paste('R2=',format(Rsq,digit=2),sep=''),
  #           ylim=c(0,1.1*max(decomp.summary$percentage)),
  #           xaxt='n',col=1+(pv<0.05))
  #  pxticks = seq(1,length(decomp.summary$percentage),10)
   # axis(side=1,at=pxticks,labels=sample_names[pxticks],las=2)
   # dev.off()
    
  return(list(
	name=mixture_file,
	Perc=decomp.summary,
    pv=pv, 
    NNFIT=NNFIT,
	R2=Rsq
    ))  
}


